### YamlMime:ManagedReference
items:
- uid: "util.MathUtils"
  id: "MathUtils"
  parent: "util"
  children:
  - "util.MathUtils.MathUtils()"
  - "util.MathUtils.boundingSphere(org.joml.Vector2f,org.joml.Vector2f...)"
  - "util.MathUtils.constrain(float,float,float)"
  - "util.MathUtils.constrain(int,int,int)"
  - "util.MathUtils.convexHull(org.joml.Vector2f[])"
  - "util.MathUtils.copy(org.joml.Vector2f[])"
  - "util.MathUtils.dist(float,float,float,float)"
  - "util.MathUtils.dist(org.joml.Vector2f,org.joml.Vector2f)"
  - "util.MathUtils.encode(int)"
  - "util.MathUtils.encode(int[])"
  - "util.MathUtils.expandingPolytopeAlgorithm(physics.collision.shape.PrimitiveShape,physics.collision.shape.PrimitiveShape,org.joml.Vector2f[])"
  - "util.MathUtils.fastFloor(double)"
  - "util.MathUtils.fastFloor(float)"
  - "util.MathUtils.fastRandom(int,int)"
  - "util.MathUtils.fastRandom(long,long)"
  - "util.MathUtils.gjksmCollision(physics.collision.shape.PrimitiveShape,physics.collision.shape.PrimitiveShape)"
  - "util.MathUtils.inCircle(float,float,float,float,float)"
  - "util.MathUtils.inCircle(org.joml.Vector2f,float,float,float)"
  - "util.MathUtils.inCircle(org.joml.Vector2f,org.joml.Vector2f,float)"
  - "util.MathUtils.inRect(float,float,float,float,float,float)"
  - "util.MathUtils.inRect(org.joml.Vector2f,float,float,float,float)"
  - "util.MathUtils.lerp(float,float,float)"
  - "util.MathUtils.map(float,float,float,float,float)"
  - "util.MathUtils.maxDotPoint(org.joml.Vector2f[],org.joml.Vector2f)"
  - "util.MathUtils.maxDotPointMinkDiff(physics.collision.shape.PrimitiveShape,physics.collision.shape.PrimitiveShape,org.joml.Vector2f)"
  - "util.MathUtils.polygonCentroid(org.joml.Vector2f...)"
  - "util.MathUtils.radian(float)"
  - "util.MathUtils.random(float,float)"
  - "util.MathUtils.randomInt(int,int)"
  - "util.MathUtils.rayCastIntersection(org.joml.Vector2f,org.joml.Vector2f,org.joml.Vector2f,org.joml.Vector2f)"
  - "util.MathUtils.rayCastIntersectionPoint(org.joml.Vector2f,org.joml.Vector2f,org.joml.Vector2f,org.joml.Vector2f)"
  - "util.MathUtils.rayCastToLineIntersectionPoint(org.joml.Vector2f,org.joml.Vector2f,org.joml.Vector2f,org.joml.Vector2f)"
  - "util.MathUtils.rectInRect(util.Transform,util.Transform)"
  - "util.MathUtils.rotateAroundOrigin(org.joml.Vector2f,float)"
  - "util.MathUtils.rotateAroundPoint(org.joml.Vector2f,org.joml.Vector2f,float)"
  - "util.MathUtils.round(float)"
  - "util.MathUtils.shiftOverwrite(float[],int,int)"
  - "util.MathUtils.solveSimultaneousEquations(org.joml.Matrix3x2f)"
  langs:
  - "java"
  name: "MathUtils"
  nameWithType: "MathUtils"
  fullName: "util.MathUtils"
  type: "Class"
  package: "util"
  summary: "An util class containing a lot of useful methods to do maths and physics calculations."
  syntax:
    content: "public class MathUtils"
  inheritance:
  - "java.lang.Object"
  inheritedMembers:
  - "java.lang.Object.clone()"
  - "java.lang.Object.equals(java.lang.Object)"
  - "java.lang.Object.finalize()"
  - "java.lang.Object.getClass()"
  - "java.lang.Object.hashCode()"
  - "java.lang.Object.notify()"
  - "java.lang.Object.notifyAll()"
  - "java.lang.Object.toString()"
  - "java.lang.Object.wait()"
  - "java.lang.Object.wait(long)"
  - "java.lang.Object.wait(long,int)"
- uid: "util.MathUtils.MathUtils()"
  id: "MathUtils()"
  parent: "util.MathUtils"
  langs:
  - "java"
  name: "MathUtils()"
  nameWithType: "MathUtils.MathUtils()"
  fullName: "util.MathUtils.MathUtils()"
  overload: "util.MathUtils.MathUtils*"
  type: "Constructor"
  package: "util"
  syntax:
    content: "public MathUtils()"
- uid: "util.MathUtils.boundingSphere(org.joml.Vector2f,org.joml.Vector2f...)"
  id: "boundingSphere(org.joml.Vector2f,org.joml.Vector2f...)"
  parent: "util.MathUtils"
  langs:
  - "java"
  name: "boundingSphere(Vector2f centroid, Vector2f[] vertices)"
  nameWithType: "MathUtils.boundingSphere(Vector2f centroid, Vector2f[] vertices)"
  fullName: "util.MathUtils.boundingSphere(Vector2f centroid, Vector2f[] vertices)"
  overload: "util.MathUtils.boundingSphere*"
  type: "Method"
  package: "util"
  summary: "Calculates the radius of a minimum sphere that contains the given polygon and shares the same centroid."
  syntax:
    content: "public static float boundingSphere(Vector2f centroid, Vector2f[] vertices)"
    parameters:
    - id: "centroid"
      type: "org.joml.Vector2f"
      description: "the centroid of the polygon"
    - id: "vertices"
      type: "org.joml.Vector2f[]"
      description: "the vertices of the polygon"
    return:
      type: "float"
      description: "the minimum sphere containing the polygon"
- uid: "util.MathUtils.constrain(float,float,float)"
  id: "constrain(float,float,float)"
  parent: "util.MathUtils"
  langs:
  - "java"
  name: "constrain(float value, float min, float max)"
  nameWithType: "MathUtils.constrain(float value, float min, float max)"
  fullName: "util.MathUtils.constrain(float value, float min, float max)"
  overload: "util.MathUtils.constrain*"
  type: "Method"
  package: "util"
  summary: "Takes a float value clamps/constrains it between a minimum and maximum."
  syntax:
    content: "public static float constrain(float value, float min, float max)"
    parameters:
    - id: "value"
      type: "float"
      description: "Input to be constrained"
    - id: "min"
      type: "float"
      description: "Minimum possible value"
    - id: "max"
      type: "float"
      description: "Maximum possible value"
    return:
      type: "float"
      description: "Constrained value as a float."
- uid: "util.MathUtils.constrain(int,int,int)"
  id: "constrain(int,int,int)"
  parent: "util.MathUtils"
  langs:
  - "java"
  name: "constrain(int value, int min, int max)"
  nameWithType: "MathUtils.constrain(int value, int min, int max)"
  fullName: "util.MathUtils.constrain(int value, int min, int max)"
  overload: "util.MathUtils.constrain*"
  type: "Method"
  package: "util"
  summary: "Takes an integer value clamps/constrains it between a minimum and maximum."
  syntax:
    content: "public static int constrain(int value, int min, int max)"
    parameters:
    - id: "value"
      type: "int"
      description: "Input to be constrained"
    - id: "min"
      type: "int"
      description: "Minimum possible value"
    - id: "max"
      type: "int"
      description: "Maximum possible value"
    return:
      type: "int"
      description: "Constrained value as an int."
- uid: "util.MathUtils.convexHull(org.joml.Vector2f[])"
  id: "convexHull(org.joml.Vector2f[])"
  parent: "util.MathUtils"
  langs:
  - "java"
  name: "convexHull(Vector2f[] points)"
  nameWithType: "MathUtils.convexHull(Vector2f[] points)"
  fullName: "util.MathUtils.convexHull(Vector2f[] points)"
  overload: "util.MathUtils.convexHull*"
  type: "Method"
  package: "util"
  summary: "Calculates the convex hull of a given set of points using Jarvis March. The result will have the same length as the input, but not all of them have to be filled in depending on the input. If the input set is just a set of points already defining a convex polygon, the points are just sorted."
  syntax:
    content: "public static Vector2f[] convexHull(Vector2f[] points)"
    parameters:
    - id: "points"
      type: "org.joml.Vector2f[]"
      description: "the set of points forming the convex shape"
    return:
      type: "org.joml.Vector2f[]"
      description: "a sorted array of points forming the convex hull of all input points"
- uid: "util.MathUtils.copy(org.joml.Vector2f[])"
  id: "copy(org.joml.Vector2f[])"
  parent: "util.MathUtils"
  langs:
  - "java"
  name: "copy(Vector2f[] original)"
  nameWithType: "MathUtils.copy(Vector2f[] original)"
  fullName: "util.MathUtils.copy(Vector2f[] original)"
  overload: "util.MathUtils.copy*"
  type: "Method"
  package: "util"
  summary: "Make a dereferenced copy of a vector array"
  syntax:
    content: "public static Vector2f[] copy(Vector2f[] original)"
    parameters:
    - id: "original"
      type: "org.joml.Vector2f[]"
      description: "the original array"
    return:
      type: "org.joml.Vector2f[]"
      description: "a array containing a copy of each vector"
- uid: "util.MathUtils.dist(float,float,float,float)"
  id: "dist(float,float,float,float)"
  parent: "util.MathUtils"
  langs:
  - "java"
  name: "dist(float x1, float y1, float x2, float y2)"
  nameWithType: "MathUtils.dist(float x1, float y1, float x2, float y2)"
  fullName: "util.MathUtils.dist(float x1, float y1, float x2, float y2)"
  overload: "util.MathUtils.dist*"
  type: "Method"
  package: "util"
  summary: "Returns the distance between two sets of X and Y coordinates."
  syntax:
    content: "public static float dist(float x1, float y1, float x2, float y2)"
    parameters:
    - id: "x1"
      type: "float"
      description: "First X coordinate"
    - id: "y1"
      type: "float"
      description: "First Y coordinate"
    - id: "x2"
      type: "float"
      description: "Second X coordinate"
    - id: "y2"
      type: "float"
      description: "Second Y coordinate"
    return:
      type: "float"
      description: "Returns the distance as a float."
- uid: "util.MathUtils.dist(org.joml.Vector2f,org.joml.Vector2f)"
  id: "dist(org.joml.Vector2f,org.joml.Vector2f)"
  parent: "util.MathUtils"
  langs:
  - "java"
  name: "dist(Vector2f pos1, Vector2f pos2)"
  nameWithType: "MathUtils.dist(Vector2f pos1, Vector2f pos2)"
  fullName: "util.MathUtils.dist(Vector2f pos1, Vector2f pos2)"
  overload: "util.MathUtils.dist*"
  type: "Method"
  package: "util"
  summary: "Returns the distance between two sets of X and Y coordinates in the form of \"physics.Vector2\"s."
  syntax:
    content: "public static float dist(Vector2f pos1, Vector2f pos2)"
    parameters:
    - id: "pos1"
      type: "org.joml.Vector2f"
      description: "First physics.Vector2 position"
    - id: "pos2"
      type: "org.joml.Vector2f"
      description: "Second physics.Vector2 position"
    return:
      type: "float"
      description: "Returns the distance as a float."
- uid: "util.MathUtils.encode(int)"
  id: "encode(int)"
  parent: "util.MathUtils"
  langs:
  - "java"
  name: "encode(int data)"
  nameWithType: "MathUtils.encode(int data)"
  fullName: "util.MathUtils.encode(int data)"
  overload: "util.MathUtils.encode*"
  type: "Method"
  package: "util"
  summary: "Encodes a given input into a short. Note, that the range of Short is 16 bytes and therefore only 0-14 (15 different values) can be encoded. Any value that is not within this range, will lead to undefined behaviour."
  syntax:
    content: "public static short encode(int data)"
    parameters:
    - id: "data"
      type: "int"
      description: "the integer in range to encode"
    return:
      type: "short"
      description: "the encoded data as a short"
- uid: "util.MathUtils.encode(int[])"
  id: "encode(int[])"
  parent: "util.MathUtils"
  langs:
  - "java"
  name: "encode(int[] data)"
  nameWithType: "MathUtils.encode(int[] data)"
  fullName: "util.MathUtils.encode(int[] data)"
  overload: "util.MathUtils.encode*"
  type: "Method"
  package: "util"
  summary: "Encodes all given input into a short. Note, that the range of Short is 16 bytes and therefore only 0-14 (15 different values) can be encoded. Any value that is not within this range, will lead to undefined behaviour."
  syntax:
    content: "public static short encode(int[] data)"
    parameters:
    - id: "data"
      type: "int[]"
      description: "a list of integers in no particular order"
    return:
      type: "short"
      description: "the encoded data as a short"
- uid: "util.MathUtils.expandingPolytopeAlgorithm(physics.collision.shape.PrimitiveShape,physics.collision.shape.PrimitiveShape,org.joml.Vector2f[])"
  id: "expandingPolytopeAlgorithm(physics.collision.shape.PrimitiveShape,physics.collision.shape.PrimitiveShape,org.joml.Vector2f[])"
  parent: "util.MathUtils"
  langs:
  - "java"
  name: "expandingPolytopeAlgorithm(PrimitiveShape shapeA, PrimitiveShape shapeB, Vector2f[] simplex)"
  nameWithType: "MathUtils.expandingPolytopeAlgorithm(PrimitiveShape shapeA, PrimitiveShape shapeB, Vector2f[] simplex)"
  fullName: "util.MathUtils.expandingPolytopeAlgorithm(PrimitiveShape shapeA, PrimitiveShape shapeB, Vector2f[] simplex)"
  overload: "util.MathUtils.expandingPolytopeAlgorithm*"
  type: "Method"
  package: "util"
  summary: "The EPA algorithm to find a penetration vector of two given shapes and the result of the GJK algorithm. Since it depends on the GJK algorithm, this algorithm will fail in an undefined way, if the shapes do not actually collide."
  syntax:
    content: "public static Optional<Vector2f> expandingPolytopeAlgorithm(PrimitiveShape shapeA, PrimitiveShape shapeB, Vector2f[] simplex)"
    parameters:
    - id: "shapeA"
      type: "physics.collision.shape.PrimitiveShape"
      description: "the first shape"
    - id: "shapeB"
      type: "physics.collision.shape.PrimitiveShape"
      description: "the second shape, that collides with the first one"
    - id: "simplex"
      type: "org.joml.Vector2f[]"
      description: "the simplex returned by GJK or any simplex inside both shapes borders enclosing the overlapping area of both shapes"
    return:
      type: "java.util.Optional<org.joml.Vector2f>"
      description: "the penetration vector of both shapes, if there is one found within a series of steps"
- uid: "util.MathUtils.fastFloor(double)"
  id: "fastFloor(double)"
  parent: "util.MathUtils"
  langs:
  - "java"
  name: "fastFloor(double x)"
  nameWithType: "MathUtils.fastFloor(double x)"
  fullName: "util.MathUtils.fastFloor(double x)"
  overload: "util.MathUtils.fastFloor*"
  type: "Method"
  package: "util"
  summary: "Flooring a value fast by using casting instead of actual calculation."
  syntax:
    content: "public static int fastFloor(double x)"
    parameters:
    - id: "x"
      type: "double"
      description: "the value to floor"
    return:
      type: "int"
      description: "the floored integer value"
- uid: "util.MathUtils.fastFloor(float)"
  id: "fastFloor(float)"
  parent: "util.MathUtils"
  langs:
  - "java"
  name: "fastFloor(float x)"
  nameWithType: "MathUtils.fastFloor(float x)"
  fullName: "util.MathUtils.fastFloor(float x)"
  overload: "util.MathUtils.fastFloor*"
  type: "Method"
  package: "util"
  summary: "Flooring a value fast by using casting instead of actual calculation."
  syntax:
    content: "public static int fastFloor(float x)"
    parameters:
    - id: "x"
      type: "float"
      description: "the value to floor"
    return:
      type: "int"
      description: "the floored integer value"
- uid: "util.MathUtils.fastRandom(int,int)"
  id: "fastRandom(int,int)"
  parent: "util.MathUtils"
  langs:
  - "java"
  name: "fastRandom(int pos, int seed)"
  nameWithType: "MathUtils.fastRandom(int pos, int seed)"
  fullName: "util.MathUtils.fastRandom(int pos, int seed)"
  overload: "util.MathUtils.fastRandom*"
  type: "Method"
  package: "util"
  summary: "An alternative randomization method.\nBased on noise generation and hashing techniques - it generates a random value using a position and a seed.\n\\- Could also be used as one dimensional value noise.\n\\- Guarantees reproducible results for identical inputs.\n\\- The seed is less significant than the position.\n"
  syntax:
    content: "public static float fastRandom(int pos, int seed)"
    parameters:
    - id: "pos"
      type: "int"
      description: "the position in the spectrum."
    - id: "seed"
      type: "int"
      description: "the seed used for fixing the spectrum"
    return:
      type: "float"
      description: "a reproducible randomized number between 0 and 1"
- uid: "util.MathUtils.fastRandom(long,long)"
  id: "fastRandom(long,long)"
  parent: "util.MathUtils"
  langs:
  - "java"
  name: "fastRandom(long pos, long seed)"
  nameWithType: "MathUtils.fastRandom(long pos, long seed)"
  fullName: "util.MathUtils.fastRandom(long pos, long seed)"
  overload: "util.MathUtils.fastRandom*"
  type: "Method"
  package: "util"
  summary: "An alternative randomization method.\nBased on noise generation and hashing techniques - it generates a random value using a position and a seed.\n\\- Could also be used as one dimensional value noise.\n\\- Guarantees reproducible results for identical inputs.\n\\- The seed is less significant than the position.\n"
  syntax:
    content: "public static double fastRandom(long pos, long seed)"
    parameters:
    - id: "pos"
      type: "long"
      description: "the position in the spectrum."
    - id: "seed"
      type: "long"
      description: "the seed used for fixing the spectrum"
    return:
      type: "double"
      description: "a reproducible randomized number between 0 and 1"
- uid: "util.MathUtils.gjksmCollision(physics.collision.shape.PrimitiveShape,physics.collision.shape.PrimitiveShape)"
  id: "gjksmCollision(physics.collision.shape.PrimitiveShape,physics.collision.shape.PrimitiveShape)"
  parent: "util.MathUtils"
  langs:
  - "java"
  name: "gjksmCollision(PrimitiveShape shapeA, PrimitiveShape shapeB)"
  nameWithType: "MathUtils.gjksmCollision(PrimitiveShape shapeA, PrimitiveShape shapeB)"
  fullName: "util.MathUtils.gjksmCollision(PrimitiveShape shapeA, PrimitiveShape shapeB)"
  overload: "util.MathUtils.gjksmCollision*"
  type: "Method"
  package: "util"
  summary: "Calculates whether a shape collides/overlaps with another shape using their support function only.\n\nThe support function of a shape calculates the furthest point in a set direction.\n\nBy GJKSM it is required, that both given shapes are convex shapes. If you wanna test concave shapes, you will have to split them into convex shapes first.\n\nThis method is based on the GJKSM invariant named by and after GJK the basic underlying principle Stelly a gamedev working at valve (at least at the time) and Muratori reducing its compexity down to testing instead of heavy math.\n\nThis algorithm below is adjusted to 2d space instead of 3d space and therefore some checks arent necessary, since an unfinished triangle (3 points, 2 vectors) already determines collision.\n\nThis algorithm was implemented and alternated on 19th of June by Julius K."
  syntax:
    content: "public static CollisionInformation gjksmCollision(PrimitiveShape shapeA, PrimitiveShape shapeB)"
    parameters:
    - id: "shapeA"
      type: "physics.collision.shape.PrimitiveShape"
      description: "shape a"
    - id: "shapeB"
      type: "physics.collision.shape.PrimitiveShape"
      description: "shape b"
    return:
      type: "physics.collision.CollisionInformation"
      description: "whether shape a and shape b intersect"
- uid: "util.MathUtils.inCircle(float,float,float,float,float)"
  id: "inCircle(float,float,float,float,float)"
  parent: "util.MathUtils"
  langs:
  - "java"
  name: "inCircle(float inX, float inY, float circleX, float circleY, float radius)"
  nameWithType: "MathUtils.inCircle(float inX, float inY, float circleX, float circleY, float radius)"
  fullName: "util.MathUtils.inCircle(float inX, float inY, float circleX, float circleY, float radius)"
  overload: "util.MathUtils.inCircle*"
  type: "Method"
  package: "util"
  summary: "Checks if a set of X and Y coordinates are inside of a circle."
  syntax:
    content: "public static boolean inCircle(float inX, float inY, float circleX, float circleY, float radius)"
    parameters:
    - id: "inX"
      type: "float"
      description: "X position of point to check"
    - id: "inY"
      type: "float"
      description: "Y position of point to check"
    - id: "circleX"
      type: "float"
      description: "X position of circle"
    - id: "circleY"
      type: "float"
      description: "Y position of circle"
    - id: "radius"
      type: "float"
      description: "Radius of circle"
    return:
      type: "boolean"
      description: "Returns true if the point is inside the circle, otherwise returns false."
- uid: "util.MathUtils.inCircle(org.joml.Vector2f,float,float,float)"
  id: "inCircle(org.joml.Vector2f,float,float,float)"
  parent: "util.MathUtils"
  langs:
  - "java"
  name: "inCircle(Vector2f in, float circleX, float circleY, float radius)"
  nameWithType: "MathUtils.inCircle(Vector2f in, float circleX, float circleY, float radius)"
  fullName: "util.MathUtils.inCircle(Vector2f in, float circleX, float circleY, float radius)"
  overload: "util.MathUtils.inCircle*"
  type: "Method"
  package: "util"
  summary: "Checks if a set of X and Y coordinates are inside of a circle."
  syntax:
    content: "public static boolean inCircle(Vector2f in, float circleX, float circleY, float radius)"
    parameters:
    - id: "in"
      type: "org.joml.Vector2f"
      description: "physics.org.joml.Vector2f containing coordinates of point to check"
    - id: "circleX"
      type: "float"
      description: "X position of circle"
    - id: "circleY"
      type: "float"
      description: "Y position of circle"
    - id: "radius"
      type: "float"
      description: "Radius of circle"
    return:
      type: "boolean"
      description: "Returns true if the point is inside the circle, otherwise returns false."
- uid: "util.MathUtils.inCircle(org.joml.Vector2f,org.joml.Vector2f,float)"
  id: "inCircle(org.joml.Vector2f,org.joml.Vector2f,float)"
  parent: "util.MathUtils"
  langs:
  - "java"
  name: "inCircle(Vector2f in, Vector2f circle, float radius)"
  nameWithType: "MathUtils.inCircle(Vector2f in, Vector2f circle, float radius)"
  fullName: "util.MathUtils.inCircle(Vector2f in, Vector2f circle, float radius)"
  overload: "util.MathUtils.inCircle*"
  type: "Method"
  package: "util"
  summary: "Checks if a set of X and Y coordinates are inside of a circle."
  syntax:
    content: "public static boolean inCircle(Vector2f in, Vector2f circle, float radius)"
    parameters:
    - id: "in"
      type: "org.joml.Vector2f"
      description: "physics.Vector2f containing coordinates of point to check"
    - id: "circle"
      type: "org.joml.Vector2f"
      description: "physics.Vector2f containing coordinates of the center of the circle"
    - id: "radius"
      type: "float"
      description: "Radius of circle"
    return:
      type: "boolean"
      description: "Returns true if the point is inside the circle, otherwise returns false."
- uid: "util.MathUtils.inRect(float,float,float,float,float,float)"
  id: "inRect(float,float,float,float,float,float)"
  parent: "util.MathUtils"
  langs:
  - "java"
  name: "inRect(float inX, float inY, float rectX, float rectY, float rectWidth, float rectHeight)"
  nameWithType: "MathUtils.inRect(float inX, float inY, float rectX, float rectY, float rectWidth, float rectHeight)"
  fullName: "util.MathUtils.inRect(float inX, float inY, float rectX, float rectY, float rectWidth, float rectHeight)"
  overload: "util.MathUtils.inRect*"
  type: "Method"
  package: "util"
  summary: "Checks if a set of X and Y coordinates are inside of a rectangle."
  syntax:
    content: "public static boolean inRect(float inX, float inY, float rectX, float rectY, float rectWidth, float rectHeight)"
    parameters:
    - id: "inX"
      type: "float"
      description: "X position of point to check"
    - id: "inY"
      type: "float"
      description: "Y position of point to check"
    - id: "rectX"
      type: "float"
      description: "X position of rectangle"
    - id: "rectY"
      type: "float"
      description: "Y position of rectangle"
    - id: "rectWidth"
      type: "float"
      description: "Width of rectangle"
    - id: "rectHeight"
      type: "float"
      description: "Height of rectangle"
    return:
      type: "boolean"
      description: "Returns true if the point is inside the rectangle, otherwise returns false."
- uid: "util.MathUtils.inRect(org.joml.Vector2f,float,float,float,float)"
  id: "inRect(org.joml.Vector2f,float,float,float,float)"
  parent: "util.MathUtils"
  langs:
  - "java"
  name: "inRect(Vector2f in, float rectX, float rectY, float rectWidth, float rectHeight)"
  nameWithType: "MathUtils.inRect(Vector2f in, float rectX, float rectY, float rectWidth, float rectHeight)"
  fullName: "util.MathUtils.inRect(Vector2f in, float rectX, float rectY, float rectWidth, float rectHeight)"
  overload: "util.MathUtils.inRect*"
  type: "Method"
  package: "util"
  summary: "Checks if a set of X and Y coordinates are inside of a rectangle."
  syntax:
    content: "public static boolean inRect(Vector2f in, float rectX, float rectY, float rectWidth, float rectHeight)"
    parameters:
    - id: "in"
      type: "org.joml.Vector2f"
      description: "physics.Vector2f containing coordinates of point to check"
    - id: "rectX"
      type: "float"
      description: "X position of rectangle"
    - id: "rectY"
      type: "float"
      description: "Y position of rectangle"
    - id: "rectWidth"
      type: "float"
      description: "Width of rectangle"
    - id: "rectHeight"
      type: "float"
      description: "Height of rectangle"
    return:
      type: "boolean"
      description: "Returns true if the point is inside the rectangle, otherwise returns false."
- uid: "util.MathUtils.lerp(float,float,float)"
  id: "lerp(float,float,float)"
  parent: "util.MathUtils"
  langs:
  - "java"
  name: "lerp(float start, float end, float amt)"
  nameWithType: "MathUtils.lerp(float start, float end, float amt)"
  fullName: "util.MathUtils.lerp(float start, float end, float amt)"
  overload: "util.MathUtils.lerp*"
  type: "Method"
  package: "util"
  summary: "Linearly interpolates between floats by a certain amount."
  syntax:
    content: "public static float lerp(float start, float end, float amt)"
    parameters:
    - id: "start"
      type: "float"
      description: "starting value"
    - id: "end"
      type: "float"
      description: "ending value"
    - id: "amt"
      type: "float"
      description: "amount to interpolate (0-1)"
    return:
      type: "float"
      description: "returns a float that is the lerp of the two values by the amount."
- uid: "util.MathUtils.map(float,float,float,float,float)"
  id: "map(float,float,float,float,float)"
  parent: "util.MathUtils"
  langs:
  - "java"
  name: "map(float value, float start1, float stop1, float start2, float stop2)"
  nameWithType: "MathUtils.map(float value, float start1, float stop1, float start2, float stop2)"
  fullName: "util.MathUtils.map(float value, float start1, float stop1, float start2, float stop2)"
  overload: "util.MathUtils.map*"
  type: "Method"
  package: "util"
  summary: "Re-maps a number from one range to another."
  syntax:
    content: "public static float map(float value, float start1, float stop1, float start2, float stop2)"
    parameters:
    - id: "value"
      type: "float"
      description: "Number to me re-mapped"
    - id: "start1"
      type: "float"
      description: "Lowest number of first range"
    - id: "stop1"
      type: "float"
      description: "Highest number of first range"
    - id: "start2"
      type: "float"
      description: "Lowest number of second range"
    - id: "stop2"
      type: "float"
      description: "Highest number of second range"
    return:
      type: "float"
      description: "Returns the re-mapped value as a float."
- uid: "util.MathUtils.maxDotPoint(org.joml.Vector2f[],org.joml.Vector2f)"
  id: "maxDotPoint(org.joml.Vector2f[],org.joml.Vector2f)"
  parent: "util.MathUtils"
  langs:
  - "java"
  name: "maxDotPoint(Vector2f[] convexShapePoints, Vector2f direction)"
  nameWithType: "MathUtils.maxDotPoint(Vector2f[] convexShapePoints, Vector2f direction)"
  fullName: "util.MathUtils.maxDotPoint(Vector2f[] convexShapePoints, Vector2f direction)"
  overload: "util.MathUtils.maxDotPoint*"
  type: "Method"
  package: "util"
  summary: "Finds the point with the highest dot product in a shape to a given direction d, by doing a simple max search over all dot products dot(a,d) where a element of A. Can be used as support function for all convex polygons defined by a finite number of points."
  syntax:
    content: "public static Vector2f maxDotPoint(Vector2f[] convexShapePoints, Vector2f direction)"
    parameters:
    - id: "convexShapePoints"
      type: "org.joml.Vector2f[]"
      description: "all points on the convex shape"
    - id: "direction"
      type: "org.joml.Vector2f"
      description: "the direction/reach to look for a point"
    return:
      type: "org.joml.Vector2f"
      description: "the point with the highest dot product by the given direction"
- uid: "util.MathUtils.maxDotPointMinkDiff(physics.collision.shape.PrimitiveShape,physics.collision.shape.PrimitiveShape,org.joml.Vector2f)"
  id: "maxDotPointMinkDiff(physics.collision.shape.PrimitiveShape,physics.collision.shape.PrimitiveShape,org.joml.Vector2f)"
  parent: "util.MathUtils"
  langs:
  - "java"
  name: "maxDotPointMinkDiff(PrimitiveShape shapeA, PrimitiveShape shapeB, Vector2f direction)"
  nameWithType: "MathUtils.maxDotPointMinkDiff(PrimitiveShape shapeA, PrimitiveShape shapeB, Vector2f direction)"
  fullName: "util.MathUtils.maxDotPointMinkDiff(PrimitiveShape shapeA, PrimitiveShape shapeB, Vector2f direction)"
  overload: "util.MathUtils.maxDotPointMinkDiff*"
  type: "Method"
  package: "util"
  summary: "Calculates the maximum point of a convex shape C in a specific direction, where C is considered the minkowskiDiff(A,B)."
  syntax:
    content: "public static Vector2f maxDotPointMinkDiff(PrimitiveShape shapeA, PrimitiveShape shapeB, Vector2f direction)"
    parameters:
    - id: "shapeA"
      type: "physics.collision.shape.PrimitiveShape"
    - id: "shapeB"
      type: "physics.collision.shape.PrimitiveShape"
    - id: "direction"
      type: "org.joml.Vector2f"
    return:
      type: "org.joml.Vector2f"
      description: "the maximum point in a specific direction"
- uid: "util.MathUtils.polygonCentroid(org.joml.Vector2f...)"
  id: "polygonCentroid(org.joml.Vector2f...)"
  parent: "util.MathUtils"
  langs:
  - "java"
  name: "polygonCentroid(Vector2f[] vertices)"
  nameWithType: "MathUtils.polygonCentroid(Vector2f[] vertices)"
  fullName: "util.MathUtils.polygonCentroid(Vector2f[] vertices)"
  overload: "util.MathUtils.polygonCentroid*"
  type: "Method"
  package: "util"
  summary: "Calculate the centroid of a polygon."
  syntax:
    content: "public static Vector2f polygonCentroid(Vector2f[] vertices)"
    parameters:
    - id: "vertices"
      type: "org.joml.Vector2f[]"
      description: "the vertices of the polygon"
    return:
      type: "org.joml.Vector2f"
      description: "the centroid of a polygon"
- uid: "util.MathUtils.radian(float)"
  id: "radian(float)"
  parent: "util.MathUtils"
  langs:
  - "java"
  name: "radian(float degree)"
  nameWithType: "MathUtils.radian(float degree)"
  fullName: "util.MathUtils.radian(float degree)"
  overload: "util.MathUtils.radian*"
  type: "Method"
  package: "util"
  summary: "Transforms an angle from degree into radian."
  syntax:
    content: "public static float radian(float degree)"
    parameters:
    - id: "degree"
      type: "float"
      description: "the angle in degree"
    return:
      type: "float"
      description: "the radian angle"
- uid: "util.MathUtils.random(float,float)"
  id: "random(float,float)"
  parent: "util.MathUtils"
  langs:
  - "java"
  name: "random(float min, float max)"
  nameWithType: "MathUtils.random(float min, float max)"
  fullName: "util.MathUtils.random(float min, float max)"
  overload: "util.MathUtils.random*"
  type: "Method"
  package: "util"
  summary: "Generates a random number from a range of floats."
  syntax:
    content: "public static float random(float min, float max)"
    parameters:
    - id: "min"
      type: "float"
      description: "Minimum possible output"
    - id: "max"
      type: "float"
      description: "Maximum possible output"
    return:
      type: "float"
      description: "returns a random float from the range passed."
- uid: "util.MathUtils.randomInt(int,int)"
  id: "randomInt(int,int)"
  parent: "util.MathUtils"
  langs:
  - "java"
  name: "randomInt(int min, int max)"
  nameWithType: "MathUtils.randomInt(int min, int max)"
  fullName: "util.MathUtils.randomInt(int min, int max)"
  overload: "util.MathUtils.randomInt*"
  type: "Method"
  package: "util"
  summary: "Generates a random number from a range of ints."
  syntax:
    content: "public static int randomInt(int min, int max)"
    parameters:
    - id: "min"
      type: "int"
      description: "Minimum possible output"
    - id: "max"
      type: "int"
      description: "Maximum possible output"
    return:
      type: "int"
      description: "returns a random int from the range passed."
- uid: "util.MathUtils.rayCastIntersection(org.joml.Vector2f,org.joml.Vector2f,org.joml.Vector2f,org.joml.Vector2f)"
  id: "rayCastIntersection(org.joml.Vector2f,org.joml.Vector2f,org.joml.Vector2f,org.joml.Vector2f)"
  parent: "util.MathUtils"
  langs:
  - "java"
  name: "rayCastIntersection(Vector2f pointA, Vector2f rayA, Vector2f pointB, Vector2f rayB)"
  nameWithType: "MathUtils.rayCastIntersection(Vector2f pointA, Vector2f rayA, Vector2f pointB, Vector2f rayB)"
  fullName: "util.MathUtils.rayCastIntersection(Vector2f pointA, Vector2f rayA, Vector2f pointB, Vector2f rayB)"
  overload: "util.MathUtils.rayCastIntersection*"
  type: "Method"
  package: "util"
  summary: "Cast two rays and see if they intersect. The solution will be calculated based on endless rays with a fixpoint and a ray direction. If a there is intersection point of both ray, they arent parallel and the factors x and y are calculated, so that intersection = pointA+x\\*rayA = pointB+y\\*rayB is valid. To ensure a finite ray, the conditions 0 <= x <= 1 and 0 <= y <= 1 are checked."
  syntax:
    content: "public static Optional<Pair<Vector2f,Vector2f>> rayCastIntersection(Vector2f pointA, Vector2f rayA, Vector2f pointB, Vector2f rayB)"
    parameters:
    - id: "pointA"
      type: "org.joml.Vector2f"
      description: "the starting point of ray 1"
    - id: "rayA"
      type: "org.joml.Vector2f"
      description: "the direction and length of ray 1"
    - id: "pointB"
      type: "org.joml.Vector2f"
      description: "the starting point of ray 2"
    - id: "rayB"
      type: "org.joml.Vector2f"
      description: "the direction and length of ray 2"
    return:
      type: "java.util.Optional<util.Pair<org.joml.Vector2f,org.joml.Vector2f>>"
      description: "a pair containing the intersection point first and a vector with factors x and y"
- uid: "util.MathUtils.rayCastIntersectionPoint(org.joml.Vector2f,org.joml.Vector2f,org.joml.Vector2f,org.joml.Vector2f)"
  id: "rayCastIntersectionPoint(org.joml.Vector2f,org.joml.Vector2f,org.joml.Vector2f,org.joml.Vector2f)"
  parent: "util.MathUtils"
  langs:
  - "java"
  name: "rayCastIntersectionPoint(Vector2f pointA, Vector2f rayA, Vector2f pointB, Vector2f rayB)"
  nameWithType: "MathUtils.rayCastIntersectionPoint(Vector2f pointA, Vector2f rayA, Vector2f pointB, Vector2f rayB)"
  fullName: "util.MathUtils.rayCastIntersectionPoint(Vector2f pointA, Vector2f rayA, Vector2f pointB, Vector2f rayB)"
  overload: "util.MathUtils.rayCastIntersectionPoint*"
  type: "Method"
  package: "util"
  summary: "Cast two rays and see if they intersect."
  syntax:
    content: "public static Optional<Vector2f> rayCastIntersectionPoint(Vector2f pointA, Vector2f rayA, Vector2f pointB, Vector2f rayB)"
    parameters:
    - id: "pointA"
      type: "org.joml.Vector2f"
      description: "the starting point of ray 1"
    - id: "rayA"
      type: "org.joml.Vector2f"
      description: "the direction and length of ray 1"
    - id: "pointB"
      type: "org.joml.Vector2f"
      description: "the starting point of ray 2"
    - id: "rayB"
      type: "org.joml.Vector2f"
      description: "the direction and length of ray 2"
    return:
      type: "java.util.Optional<org.joml.Vector2f>"
      description: "the intersection point"
- uid: "util.MathUtils.rayCastToLineIntersectionPoint(org.joml.Vector2f,org.joml.Vector2f,org.joml.Vector2f,org.joml.Vector2f)"
  id: "rayCastToLineIntersectionPoint(org.joml.Vector2f,org.joml.Vector2f,org.joml.Vector2f,org.joml.Vector2f)"
  parent: "util.MathUtils"
  langs:
  - "java"
  name: "rayCastToLineIntersectionPoint(Vector2f rayStart, Vector2f rayDirectionAndLength, Vector2f linePointA, Vector2f linePointB)"
  nameWithType: "MathUtils.rayCastToLineIntersectionPoint(Vector2f rayStart, Vector2f rayDirectionAndLength, Vector2f linePointA, Vector2f linePointB)"
  fullName: "util.MathUtils.rayCastToLineIntersectionPoint(Vector2f rayStart, Vector2f rayDirectionAndLength, Vector2f linePointA, Vector2f linePointB)"
  overload: "util.MathUtils.rayCastToLineIntersectionPoint*"
  type: "Method"
  package: "util"
  summary: "Cast a ray against a fixed line and see if they intersect."
  syntax:
    content: "public static Optional<Vector2f> rayCastToLineIntersectionPoint(Vector2f rayStart, Vector2f rayDirectionAndLength, Vector2f linePointA, Vector2f linePointB)"
    parameters:
    - id: "rayStart"
      type: "org.joml.Vector2f"
      description: "the starting point of the ray"
    - id: "rayDirectionAndLength"
      type: "org.joml.Vector2f"
      description: "the direction and length of the ray"
    - id: "linePointA"
      type: "org.joml.Vector2f"
      description: "the start point of the line"
    - id: "linePointB"
      type: "org.joml.Vector2f"
      description: "the end point of the line"
    return:
      type: "java.util.Optional<org.joml.Vector2f>"
      description: "the intersection point"
- uid: "util.MathUtils.rectInRect(util.Transform,util.Transform)"
  id: "rectInRect(util.Transform,util.Transform)"
  parent: "util.MathUtils"
  langs:
  - "java"
  name: "rectInRect(Transform t1, Transform t2)"
  nameWithType: "MathUtils.rectInRect(Transform t1, Transform t2)"
  fullName: "util.MathUtils.rectInRect(Transform t1, Transform t2)"
  overload: "util.MathUtils.rectInRect*"
  type: "Method"
  package: "util"
  summary: "Checks if a rectangle is completely inside of another rectangle."
  syntax:
    content: "public static boolean rectInRect(Transform t1, Transform t2)"
    parameters:
    - id: "t1"
      type: "util.Transform"
    - id: "t2"
      type: "util.Transform"
    return:
      type: "boolean"
      description: "returns boolean true if t1 is inside of t2"
- uid: "util.MathUtils.rotateAroundOrigin(org.joml.Vector2f,float)"
  id: "rotateAroundOrigin(org.joml.Vector2f,float)"
  parent: "util.MathUtils"
  langs:
  - "java"
  name: "rotateAroundOrigin(Vector2f point, float radianAngle)"
  nameWithType: "MathUtils.rotateAroundOrigin(Vector2f point, float radianAngle)"
  fullName: "util.MathUtils.rotateAroundOrigin(Vector2f point, float radianAngle)"
  overload: "util.MathUtils.rotateAroundOrigin*"
  type: "Method"
  package: "util"
  summary: "Rotates a point around the origin of the system."
  syntax:
    content: "public static Vector2f rotateAroundOrigin(Vector2f point, float radianAngle)"
    parameters:
    - id: "point"
      type: "org.joml.Vector2f"
      description: "the point to rotate"
    - id: "radianAngle"
      type: "float"
      description: "the radian angle to rotate"
    return:
      type: "org.joml.Vector2f"
      description: "a new point that is rotated by radianAngle starting from the given point"
- uid: "util.MathUtils.rotateAroundPoint(org.joml.Vector2f,org.joml.Vector2f,float)"
  id: "rotateAroundPoint(org.joml.Vector2f,org.joml.Vector2f,float)"
  parent: "util.MathUtils"
  langs:
  - "java"
  name: "rotateAroundPoint(Vector2f point, Vector2f relativeOrigin, float radianAngle)"
  nameWithType: "MathUtils.rotateAroundPoint(Vector2f point, Vector2f relativeOrigin, float radianAngle)"
  fullName: "util.MathUtils.rotateAroundPoint(Vector2f point, Vector2f relativeOrigin, float radianAngle)"
  overload: "util.MathUtils.rotateAroundPoint*"
  type: "Method"
  package: "util"
  summary: "Rotates a point around a given point in the same system."
  syntax:
    content: "public static Vector2f rotateAroundPoint(Vector2f point, Vector2f relativeOrigin, float radianAngle)"
    parameters:
    - id: "point"
      type: "org.joml.Vector2f"
      description: "the point to rotate"
    - id: "relativeOrigin"
      type: "org.joml.Vector2f"
      description: "the point to rotate around"
    - id: "radianAngle"
      type: "float"
      description: "the radian angle to rotate"
    return:
      type: "org.joml.Vector2f"
      description: "a new point that is rotated by radianAngle around the given relativeOrigin point starting from the given point"
- uid: "util.MathUtils.round(float)"
  id: "round(float)"
  parent: "util.MathUtils"
  langs:
  - "java"
  name: "round(float x)"
  nameWithType: "MathUtils.round(float x)"
  fullName: "util.MathUtils.round(float x)"
  overload: "util.MathUtils.round*"
  type: "Method"
  package: "util"
  summary: "This is for people who are too lazy to even import Math, but do want to import util.Utils. ¯\\\\\\_(\\\\u30c4)\\_/¯"
  syntax:
    content: "public static float round(float x)"
    parameters:
    - id: "x"
      type: "float"
      description: "Number to be rounded"
    return:
      type: "float"
      description: "Returns the rounded number \"x\"."
- uid: "util.MathUtils.shiftOverwrite(float[],int,int)"
  id: "shiftOverwrite(float[],int,int)"
  parent: "util.MathUtils"
  langs:
  - "java"
  name: "shiftOverwrite(float[] array, int fromIndex, int toIndex)"
  nameWithType: "MathUtils.shiftOverwrite(float[] array, int fromIndex, int toIndex)"
  fullName: "util.MathUtils.shiftOverwrite(float[] array, int fromIndex, int toIndex)"
  overload: "util.MathUtils.shiftOverwrite*"
  type: "Method"
  package: "util"
  summary: "Shifts a part of the array to overwrite the given region (fromIndex, toIndex) FromIndex is INCLUSIVE, ToIndex is EXCLUSIVE"
  syntax:
    content: "public static int shiftOverwrite(float[] array, int fromIndex, int toIndex)"
    parameters:
    - id: "array"
      type: "float[]"
      description: "the array from which the region has to be removed"
    - id: "fromIndex"
      type: "int"
      description: "start of the region"
    - id: "toIndex"
      type: "int"
      description: "end of the region"
    return:
      type: "int"
      description: "the new effective length"
- uid: "util.MathUtils.solveSimultaneousEquations(org.joml.Matrix3x2f)"
  id: "solveSimultaneousEquations(org.joml.Matrix3x2f)"
  parent: "util.MathUtils"
  langs:
  - "java"
  name: "solveSimultaneousEquations(Matrix3x2f linearSystem)"
  nameWithType: "MathUtils.solveSimultaneousEquations(Matrix3x2f linearSystem)"
  fullName: "util.MathUtils.solveSimultaneousEquations(Matrix3x2f linearSystem)"
  overload: "util.MathUtils.solveSimultaneousEquations*"
  type: "Method"
  package: "util"
  summary: "A universal linear system solver for two dimensional linear systems. Works usually by shifting the left 2x2 matrix to an identity matrix and read the results on the right side. This method here is using a mathematical approach and is designed to find only one result, if there is none, it may result in some kind of infinity. For more than 1 result the behaviour is undefined. Primarily used to find the intersection point of two lines or rays."
  syntax:
    content: "public static Vector2f solveSimultaneousEquations(Matrix3x2f linearSystem)"
    parameters:
    - id: "linearSystem"
      type: "org.joml.Matrix3x2f"
      description: "the two dimensional linear system"
    return:
      type: "org.joml.Vector2f"
      description: "the solution of linear system, <xref uid=\"org.joml.Matrix3x2f.m20\" data-throw-if-not-resolved=\"false\">Matrix3x2f#m20</xref> will be x and <xref uid=\"org.joml.Matrix3x2f.m21\" data-throw-if-not-resolved=\"false\">Matrix3x2f#m21</xref> will be y in the result vector"
references:
- uid: "util.MathUtils.MathUtils*"
  name: "MathUtils"
  nameWithType: "MathUtils.MathUtils"
  fullName: "util.MathUtils.MathUtils"
  package: "util"
- uid: "physics.collision.shape.PrimitiveShape"
  name: "PrimitiveShape"
  nameWithType: "PrimitiveShape"
  fullName: "physics.collision.shape.PrimitiveShape"
- uid: "physics.collision.CollisionInformation"
  name: "CollisionInformation"
  nameWithType: "CollisionInformation"
  fullName: "physics.collision.CollisionInformation"
- uid: "util.MathUtils.gjksmCollision*"
  name: "gjksmCollision"
  nameWithType: "MathUtils.gjksmCollision"
  fullName: "util.MathUtils.gjksmCollision"
  package: "util"
- uid: "org.joml.Vector2f[]"
  spec.java:
  - uid: "org.joml.Vector2f"
    name: "Vector2f"
    fullName: "org.joml.Vector2f"
  - name: "[]"
    fullName: "[]"
- uid: "java.util.Optional<org.joml.Vector2f>"
  spec.java:
  - uid: "java.util.Optional"
    name: "Optional"
    fullName: "java.util.Optional"
  - name: "<"
    fullName: "<"
  - uid: "org.joml.Vector2f"
    name: "Vector2f"
    fullName: "org.joml.Vector2f"
  - name: ">"
    fullName: ">"
- uid: "util.MathUtils.expandingPolytopeAlgorithm*"
  name: "expandingPolytopeAlgorithm"
  nameWithType: "MathUtils.expandingPolytopeAlgorithm"
  fullName: "util.MathUtils.expandingPolytopeAlgorithm"
  package: "util"
- uid: "org.joml.Vector2f"
  spec.java:
  - uid: "org.joml.Vector2f"
    name: "Vector2f"
    fullName: "org.joml.Vector2f"
- uid: "util.MathUtils.maxDotPointMinkDiff*"
  name: "maxDotPointMinkDiff"
  nameWithType: "MathUtils.maxDotPointMinkDiff"
  fullName: "util.MathUtils.maxDotPointMinkDiff"
  package: "util"
- uid: "util.MathUtils.maxDotPoint*"
  name: "maxDotPoint"
  nameWithType: "MathUtils.maxDotPoint"
  fullName: "util.MathUtils.maxDotPoint"
  package: "util"
- uid: "util.MathUtils.convexHull*"
  name: "convexHull"
  nameWithType: "MathUtils.convexHull"
  fullName: "util.MathUtils.convexHull"
  package: "util"
- uid: "org.joml.Matrix3x2f"
  spec.java:
  - uid: "org.joml.Matrix3x2f"
    name: "Matrix3x2f"
    fullName: "org.joml.Matrix3x2f"
- uid: "util.MathUtils.solveSimultaneousEquations*"
  name: "solveSimultaneousEquations"
  nameWithType: "MathUtils.solveSimultaneousEquations"
  fullName: "util.MathUtils.solveSimultaneousEquations"
  package: "util"
- uid: "util.MathUtils.rayCastIntersectionPoint*"
  name: "rayCastIntersectionPoint"
  nameWithType: "MathUtils.rayCastIntersectionPoint"
  fullName: "util.MathUtils.rayCastIntersectionPoint"
  package: "util"
- uid: "java.util.Optional<util.Pair<org.joml.Vector2f,org.joml.Vector2f>>"
  spec.java:
  - uid: "java.util.Optional"
    name: "Optional"
    fullName: "java.util.Optional"
  - name: "<"
    fullName: "<"
  - uid: "util.Pair"
    name: "Pair"
    fullName: "util.Pair"
  - name: "<"
    fullName: "<"
  - uid: "org.joml.Vector2f"
    name: "Vector2f"
    fullName: "org.joml.Vector2f"
  - name: ","
    fullName: ","
  - uid: "org.joml.Vector2f"
    name: "Vector2f"
    fullName: "org.joml.Vector2f"
  - name: ">"
    fullName: ">"
  - name: ">"
    fullName: ">"
- uid: "util.MathUtils.rayCastIntersection*"
  name: "rayCastIntersection"
  nameWithType: "MathUtils.rayCastIntersection"
  fullName: "util.MathUtils.rayCastIntersection"
  package: "util"
- uid: "util.MathUtils.rayCastToLineIntersectionPoint*"
  name: "rayCastToLineIntersectionPoint"
  nameWithType: "MathUtils.rayCastToLineIntersectionPoint"
  fullName: "util.MathUtils.rayCastToLineIntersectionPoint"
  package: "util"
- uid: "float"
  spec.java:
  - uid: "float"
    name: "float"
    fullName: "float"
- uid: "util.MathUtils.boundingSphere*"
  name: "boundingSphere"
  nameWithType: "MathUtils.boundingSphere"
  fullName: "util.MathUtils.boundingSphere"
  package: "util"
- uid: "util.MathUtils.polygonCentroid*"
  name: "polygonCentroid"
  nameWithType: "MathUtils.polygonCentroid"
  fullName: "util.MathUtils.polygonCentroid"
  package: "util"
- uid: "boolean"
  spec.java:
  - uid: "boolean"
    name: "boolean"
    fullName: "boolean"
- uid: "util.MathUtils.inCircle*"
  name: "inCircle"
  nameWithType: "MathUtils.inCircle"
  fullName: "util.MathUtils.inCircle"
  package: "util"
- uid: "util.MathUtils.inRect*"
  name: "inRect"
  nameWithType: "MathUtils.inRect"
  fullName: "util.MathUtils.inRect"
  package: "util"
- uid: "util.Transform"
  name: "Transform"
  nameWithType: "Transform"
  fullName: "util.Transform"
- uid: "util.MathUtils.rectInRect*"
  name: "rectInRect"
  nameWithType: "MathUtils.rectInRect"
  fullName: "util.MathUtils.rectInRect"
  package: "util"
- uid: "util.MathUtils.radian*"
  name: "radian"
  nameWithType: "MathUtils.radian"
  fullName: "util.MathUtils.radian"
  package: "util"
- uid: "util.MathUtils.rotateAroundOrigin*"
  name: "rotateAroundOrigin"
  nameWithType: "MathUtils.rotateAroundOrigin"
  fullName: "util.MathUtils.rotateAroundOrigin"
  package: "util"
- uid: "util.MathUtils.rotateAroundPoint*"
  name: "rotateAroundPoint"
  nameWithType: "MathUtils.rotateAroundPoint"
  fullName: "util.MathUtils.rotateAroundPoint"
  package: "util"
- uid: "util.MathUtils.random*"
  name: "random"
  nameWithType: "MathUtils.random"
  fullName: "util.MathUtils.random"
  package: "util"
- uid: "int"
  spec.java:
  - uid: "int"
    name: "int"
    fullName: "int"
- uid: "util.MathUtils.randomInt*"
  name: "randomInt"
  nameWithType: "MathUtils.randomInt"
  fullName: "util.MathUtils.randomInt"
  package: "util"
- uid: "util.MathUtils.round*"
  name: "round"
  nameWithType: "MathUtils.round"
  fullName: "util.MathUtils.round"
  package: "util"
- uid: "util.MathUtils.dist*"
  name: "dist"
  nameWithType: "MathUtils.dist"
  fullName: "util.MathUtils.dist"
  package: "util"
- uid: "util.MathUtils.map*"
  name: "map"
  nameWithType: "MathUtils.map"
  fullName: "util.MathUtils.map"
  package: "util"
- uid: "util.MathUtils.constrain*"
  name: "constrain"
  nameWithType: "MathUtils.constrain"
  fullName: "util.MathUtils.constrain"
  package: "util"
- uid: "util.MathUtils.lerp*"
  name: "lerp"
  nameWithType: "MathUtils.lerp"
  fullName: "util.MathUtils.lerp"
  package: "util"
- uid: "util.MathUtils.fastRandom*"
  name: "fastRandom"
  nameWithType: "MathUtils.fastRandom"
  fullName: "util.MathUtils.fastRandom"
  package: "util"
- uid: "long"
  spec.java:
  - uid: "long"
    name: "long"
    fullName: "long"
- uid: "double"
  spec.java:
  - uid: "double"
    name: "double"
    fullName: "double"
- uid: "util.MathUtils.fastFloor*"
  name: "fastFloor"
  nameWithType: "MathUtils.fastFloor"
  fullName: "util.MathUtils.fastFloor"
  package: "util"
- uid: "int[]"
  spec.java:
  - uid: "int"
    name: "int"
    fullName: "int"
  - name: "[]"
    fullName: "[]"
- uid: "short"
  spec.java:
  - uid: "short"
    name: "short"
    fullName: "short"
- uid: "util.MathUtils.encode*"
  name: "encode"
  nameWithType: "MathUtils.encode"
  fullName: "util.MathUtils.encode"
  package: "util"
- uid: "util.MathUtils.copy*"
  name: "copy"
  nameWithType: "MathUtils.copy"
  fullName: "util.MathUtils.copy"
  package: "util"
- uid: "float[]"
  spec.java:
  - uid: "float"
    name: "float"
    fullName: "float"
  - name: "[]"
    fullName: "[]"
- uid: "util.MathUtils.shiftOverwrite*"
  name: "shiftOverwrite"
  nameWithType: "MathUtils.shiftOverwrite"
  fullName: "util.MathUtils.shiftOverwrite"
  package: "util"
- uid: "java.lang.Object.notify()"
  name: "Object.notify()"
  nameWithType: "Object.notify()"
  fullName: "java.lang.Object.notify()"
- uid: "java.lang.Object.wait()"
  name: "Object.wait()"
  nameWithType: "Object.wait()"
  fullName: "java.lang.Object.wait()"
- uid: "java.lang.Object.finalize()"
  name: "Object.finalize()"
  nameWithType: "Object.finalize()"
  fullName: "java.lang.Object.finalize()"
- uid: "java.lang.Object.clone()"
  name: "Object.clone()"
  nameWithType: "Object.clone()"
  fullName: "java.lang.Object.clone()"
- uid: "java.lang.Object.notifyAll()"
  name: "Object.notifyAll()"
  nameWithType: "Object.notifyAll()"
  fullName: "java.lang.Object.notifyAll()"
- uid: "java.lang.Object.equals(java.lang.Object)"
  name: "Object.equals(Object)"
  nameWithType: "Object.equals(Object)"
  fullName: "java.lang.Object.equals(java.lang.Object)"
- uid: "java.lang.Object.getClass()"
  name: "Object.getClass()"
  nameWithType: "Object.getClass()"
  fullName: "java.lang.Object.getClass()"
- uid: "java.lang.Object.wait(long)"
  name: "Object.wait(long)"
  nameWithType: "Object.wait(long)"
  fullName: "java.lang.Object.wait(long)"
- uid: "java.lang.Object.hashCode()"
  name: "Object.hashCode()"
  nameWithType: "Object.hashCode()"
  fullName: "java.lang.Object.hashCode()"
- uid: "java.lang.Object.wait(long,int)"
  name: "Object.wait(long,int)"
  nameWithType: "Object.wait(long,int)"
  fullName: "java.lang.Object.wait(long,int)"
- uid: "java.lang.Object.toString()"
  name: "Object.toString()"
  nameWithType: "Object.toString()"
  fullName: "java.lang.Object.toString()"
- uid: "java.util.Optional"
  name: "Optional"
  nameWithType: "Optional"
  fullName: "java.util.Optional"
- uid: "util.Pair"
  name: "Pair"
  nameWithType: "Pair"
  fullName: "util.Pair"
- uid: "org.joml.Vector2f,org.joml.Vector2f"
  name: "Vector2f,Vector2f"
  nameWithType: "Vector2f,Vector2f"
  fullName: "org.joml.Vector2f,org.joml.Vector2f"

### YamlMime:ManagedReference
items:
- uid: "io.token.TokenStream"
  id: "TokenStream"
  parent: "io.token"
  children:
  - "io.token.TokenStream.TokenStream(java.lang.String)"
  - "io.token.TokenStream.e(io.token.TokenReader)"
  - "io.token.TokenStream.eat(io.token.TokenReader)"
  - "io.token.TokenStream.eatConditionally(io.token.TokenReader,java.util.function.Predicate<io.token.Token>)"
  - "io.token.TokenStream.eatHistorically(io.token.TokenReader,java.util.function.Predicate<java.util.LinkedList<io.token.Token>>)"
  - "io.token.TokenStream.eh(io.token.TokenReader...)"
  - "io.token.TokenStream.getHistory()"
  - "io.token.TokenStream.isOffering()"
  - "io.token.TokenStream.ne(io.token.TokenReader)"
  langs:
  - "java"
  name: "TokenStream"
  nameWithType: "TokenStream"
  fullName: "io.token.TokenStream"
  type: "Class"
  package: "io.token"
  summary: "A handy structure to perform the lexical analysis on a given <xref uid=\"java.lang.String\" data-throw-if-not-resolved=\"false\">String</xref>. Uses the <xref uid=\"\" data-throw-if-not-resolved=\"false\">Scanner</xref> class and <xref uid=\"io.token.TokenReader\" data-throw-if-not-resolved=\"false\">TokenReader</xref>s reading character by character to tokenize an input."
  syntax:
    content: "public class TokenStream"
  inheritance:
  - "java.lang.Object"
  inheritedMembers:
  - "java.lang.Object.clone()"
  - "java.lang.Object.equals(java.lang.Object)"
  - "java.lang.Object.finalize()"
  - "java.lang.Object.getClass()"
  - "java.lang.Object.hashCode()"
  - "java.lang.Object.notify()"
  - "java.lang.Object.notifyAll()"
  - "java.lang.Object.toString()"
  - "java.lang.Object.wait()"
  - "java.lang.Object.wait(long)"
  - "java.lang.Object.wait(long,int)"
- uid: "io.token.TokenStream.TokenStream(java.lang.String)"
  id: "TokenStream(java.lang.String)"
  parent: "io.token.TokenStream"
  langs:
  - "java"
  name: "TokenStream(String input)"
  nameWithType: "TokenStream.TokenStream(String input)"
  fullName: "io.token.TokenStream.TokenStream(String input)"
  overload: "io.token.TokenStream.TokenStream*"
  type: "Constructor"
  package: "io.token"
  summary: "Create a new <xref uid=\"io.token.TokenStream\" data-throw-if-not-resolved=\"false\">TokenStream</xref> for a given input <xref uid=\"java.lang.String\" data-throw-if-not-resolved=\"false\">String</xref>. Also creates an empty token history list \\{@link this\\#getHistory()\\} and the <xref uid=\"\" data-throw-if-not-resolved=\"false\">Scanner</xref> with the single character delimiter."
  syntax:
    content: "public TokenStream(String input)"
    parameters:
    - id: "input"
      type: "java.lang.String"
      description: "the input <xref uid=\"java.lang.String\" data-throw-if-not-resolved=\"false\">String</xref>"
- uid: "io.token.TokenStream.e(io.token.TokenReader)"
  id: "e(io.token.TokenReader)"
  parent: "io.token.TokenStream"
  langs:
  - "java"
  name: "e(TokenReader reader)"
  nameWithType: "TokenStream.e(TokenReader reader)"
  fullName: "io.token.TokenStream.e(TokenReader reader)"
  overload: "io.token.TokenStream.e*"
  type: "Method"
  package: "io.token"
  summary: "Used for \\{@link this\\#eatConditionally(TokenReader, Predicate)\\} to create a predicate. The predicate will match the given readers type with the last token in the history list. This means the predicate passes, if the latest/most recent eaten token is equal to the given one."
  syntax:
    content: "public static Predicate<Token> e(TokenReader reader)"
    parameters:
    - id: "reader"
      type: "io.token.TokenReader"
      description: "the reader containing the type to match in history"
    return:
      type: "java.util.function.Predicate<io.token.Token>"
      description: "whether the most recent token matches the given one - as predicate"
- uid: "io.token.TokenStream.eat(io.token.TokenReader)"
  id: "eat(io.token.TokenReader)"
  parent: "io.token.TokenStream"
  langs:
  - "java"
  name: "eat(TokenReader reader)"
  nameWithType: "TokenStream.eat(TokenReader reader)"
  fullName: "io.token.TokenStream.eat(TokenReader reader)"
  overload: "io.token.TokenStream.eat*"
  type: "Method"
  package: "io.token"
  summary: "Try to read a token using the given <xref uid=\"io.token.TokenReader\" data-throw-if-not-resolved=\"false\">TokenReader</xref> based on the current position of the internal <xref uid=\"\" data-throw-if-not-resolved=\"false\">Scanner</xref>. This method will read and add a new token to the history, if the <xref uid=\"io.token.TokenReader.canRead(java.util.Scanner)\" data-throw-if-not-resolved=\"false\">TokenReader#canRead(Scanner)</xref> method returns true."
  syntax:
    content: "public TokenStream eat(TokenReader reader)"
    parameters:
    - id: "reader"
      type: "io.token.TokenReader"
      description: "the reader to read the next token"
    return:
      type: "io.token.TokenStream"
      description: "this stream"
- uid: "io.token.TokenStream.eatConditionally(io.token.TokenReader,java.util.function.Predicate<io.token.Token>)"
  id: "eatConditionally(io.token.TokenReader,java.util.function.Predicate<io.token.Token>)"
  parent: "io.token.TokenStream"
  langs:
  - "java"
  name: "eatConditionally(TokenReader reader, Predicate<Token> previousToken)"
  nameWithType: "TokenStream.eatConditionally(TokenReader reader, Predicate<Token> previousToken)"
  fullName: "io.token.TokenStream.eatConditionally(TokenReader reader, Predicate<Token> previousToken)"
  overload: "io.token.TokenStream.eatConditionally*"
  type: "Method"
  package: "io.token"
  summary: "Try to read a token if the previous token in history matches the given condition."
  syntax:
    content: "public TokenStream eatConditionally(TokenReader reader, Predicate<Token> previousToken)"
    parameters:
    - id: "reader"
      type: "io.token.TokenReader"
      description: "the reader to read the next token"
    - id: "previousToken"
      type: "java.util.function.Predicate<io.token.Token>"
      description: "the condition for the previous token"
    return:
      type: "io.token.TokenStream"
      description: "this stream"
- uid: "io.token.TokenStream.eatHistorically(io.token.TokenReader,java.util.function.Predicate<java.util.LinkedList<io.token.Token>>)"
  id: "eatHistorically(io.token.TokenReader,java.util.function.Predicate<java.util.LinkedList<io.token.Token>>)"
  parent: "io.token.TokenStream"
  langs:
  - "java"
  name: "eatHistorically(TokenReader reader, Predicate<LinkedList<Token>> previousToken)"
  nameWithType: "TokenStream.eatHistorically(TokenReader reader, Predicate<LinkedList<Token>> previousToken)"
  fullName: "io.token.TokenStream.eatHistorically(TokenReader reader, Predicate<LinkedList<Token>> previousToken)"
  overload: "io.token.TokenStream.eatHistorically*"
  type: "Method"
  package: "io.token"
  summary: "Try to read a token if all previous tokens in history match the given condition."
  syntax:
    content: "public TokenStream eatHistorically(TokenReader reader, Predicate<LinkedList<Token>> previousToken)"
    parameters:
    - id: "reader"
      type: "io.token.TokenReader"
      description: "the reader to read the next token"
    - id: "previousToken"
      type: "java.util.function.Predicate<java.util.LinkedList<io.token.Token>>"
      description: "the conditions for the previous tokens"
    return:
      type: "io.token.TokenStream"
      description: "this stream"
- uid: "io.token.TokenStream.eh(io.token.TokenReader...)"
  id: "eh(io.token.TokenReader...)"
  parent: "io.token.TokenStream"
  langs:
  - "java"
  name: "eh(TokenReader[] readers)"
  nameWithType: "TokenStream.eh(TokenReader[] readers)"
  fullName: "io.token.TokenStream.eh(TokenReader[] readers)"
  overload: "io.token.TokenStream.eh*"
  type: "Method"
  package: "io.token"
  summary: "Used for \\{@link this\\#eatHistorically(TokenReader, Predicate)\\} to create a predicate. Calling this method with A,B,C would result in a predicate that matches if the recent history ends with A,B,C. Where C is the most recent entry - therefore the given tokens get matched with the end of the history list."
  syntax:
    content: "public static Predicate<LinkedList<Token>> eh(TokenReader[] readers)"
    parameters:
    - id: "readers"
      type: "io.token.TokenReader[]"
      description: "the <xref uid=\"io.token.TokenReader\" data-throw-if-not-resolved=\"false\">TokenReader</xref>s containing the types to match in history"
    return:
      type: "java.util.function.Predicate<java.util.LinkedList<io.token.Token>>"
      description: "whether the expected history is matched - as predicate"
- uid: "io.token.TokenStream.getHistory()"
  id: "getHistory()"
  parent: "io.token.TokenStream"
  langs:
  - "java"
  name: "getHistory()"
  nameWithType: "TokenStream.getHistory()"
  fullName: "io.token.TokenStream.getHistory()"
  overload: "io.token.TokenStream.getHistory*"
  type: "Method"
  package: "io.token"
  summary: "The current token history of this stream. Might produce the result at the end of calculation."
  syntax:
    content: "public LinkedList<Token> getHistory()"
    return:
      type: "java.util.LinkedList<io.token.Token>"
      description: "the current token history list."
- uid: "io.token.TokenStream.isOffering()"
  id: "isOffering()"
  parent: "io.token.TokenStream"
  langs:
  - "java"
  name: "isOffering()"
  nameWithType: "TokenStream.isOffering()"
  fullName: "io.token.TokenStream.isOffering()"
  overload: "io.token.TokenStream.isOffering*"
  type: "Method"
  package: "io.token"
  summary: "If there is any token left to read. Is identical to <xref uid=\"\" data-throw-if-not-resolved=\"false\">Scanner#hasNext()</xref> for the internal scanner."
  syntax:
    content: "public boolean isOffering()"
    return:
      type: "boolean"
      description: "whether there are characters/tokens left to be read"
- uid: "io.token.TokenStream.ne(io.token.TokenReader)"
  id: "ne(io.token.TokenReader)"
  parent: "io.token.TokenStream"
  langs:
  - "java"
  name: "ne(TokenReader reader)"
  nameWithType: "TokenStream.ne(TokenReader reader)"
  fullName: "io.token.TokenStream.ne(TokenReader reader)"
  overload: "io.token.TokenStream.ne*"
  type: "Method"
  package: "io.token"
  summary: "Used for \\{@link this\\#eatConditionally(TokenReader, Predicate)\\} to create a predicate. The predicate will NOT match the given readers type with the last token in the history list. This means the predicate passes, if the latest/most recent eaten token is NOT equal to the given one. This method is mostly the opposite to \\{@link this\\#e(TokenReader)\\}, although this predicate also passes, if there is no previous token at all."
  syntax:
    content: "public static Predicate<Token> ne(TokenReader reader)"
    parameters:
    - id: "reader"
      type: "io.token.TokenReader"
      description: "the reader containing the type to match in history"
    return:
      type: "java.util.function.Predicate<io.token.Token>"
      description: "whether the most recent token does not match the given one - as predicate"
references:
- uid: "java.lang.String"
  spec.java:
  - uid: "java.lang.String"
    name: "String"
    fullName: "java.lang.String"
- uid: "io.token.TokenStream.TokenStream*"
  name: "TokenStream"
  nameWithType: "TokenStream.TokenStream"
  fullName: "io.token.TokenStream.TokenStream"
  package: "io.token"
- uid: "io.token.TokenReader"
  name: "TokenReader"
  nameWithType: "TokenReader"
  fullName: "io.token.TokenReader"
- uid: "io.token.TokenStream.eat*"
  name: "eat"
  nameWithType: "TokenStream.eat"
  fullName: "io.token.TokenStream.eat"
  package: "io.token"
- uid: "java.util.function.Predicate<io.token.Token>"
  spec.java:
  - uid: "java.util.function.Predicate"
    name: "Predicate"
    fullName: "java.util.function.Predicate"
  - name: "<"
    fullName: "<"
  - uid: "io.token.Token"
    name: "Token"
    fullName: "io.token.Token"
  - name: ">"
    fullName: ">"
- uid: "io.token.TokenStream.eatConditionally*"
  name: "eatConditionally"
  nameWithType: "TokenStream.eatConditionally"
  fullName: "io.token.TokenStream.eatConditionally"
  package: "io.token"
- uid: "java.util.function.Predicate<java.util.LinkedList<io.token.Token>>"
  spec.java:
  - uid: "java.util.function.Predicate"
    name: "Predicate"
    fullName: "java.util.function.Predicate"
  - name: "<"
    fullName: "<"
  - uid: "java.util.LinkedList"
    name: "LinkedList"
    fullName: "java.util.LinkedList"
  - name: "<"
    fullName: "<"
  - uid: "io.token.Token"
    name: "Token"
    fullName: "io.token.Token"
  - name: ">"
    fullName: ">"
  - name: ">"
    fullName: ">"
- uid: "io.token.TokenStream.eatHistorically*"
  name: "eatHistorically"
  nameWithType: "TokenStream.eatHistorically"
  fullName: "io.token.TokenStream.eatHistorically"
  package: "io.token"
- uid: "java.util.LinkedList<io.token.Token>"
  spec.java:
  - uid: "java.util.LinkedList"
    name: "LinkedList"
    fullName: "java.util.LinkedList"
  - name: "<"
    fullName: "<"
  - uid: "io.token.Token"
    name: "Token"
    fullName: "io.token.Token"
  - name: ">"
    fullName: ">"
- uid: "io.token.TokenStream.getHistory*"
  name: "getHistory"
  nameWithType: "TokenStream.getHistory"
  fullName: "io.token.TokenStream.getHistory"
  package: "io.token"
- uid: "boolean"
  spec.java:
  - uid: "boolean"
    name: "boolean"
    fullName: "boolean"
- uid: "io.token.TokenStream.isOffering*"
  name: "isOffering"
  nameWithType: "TokenStream.isOffering"
  fullName: "io.token.TokenStream.isOffering"
  package: "io.token"
- uid: "io.token.TokenReader[]"
  spec.java:
  - uid: "io.token.TokenReader"
    name: "TokenReader"
    fullName: "io.token.TokenReader"
  - name: "[]"
    fullName: "[]"
- uid: "io.token.TokenStream.eh*"
  name: "eh"
  nameWithType: "TokenStream.eh"
  fullName: "io.token.TokenStream.eh"
  package: "io.token"
- uid: "io.token.TokenStream.e*"
  name: "e"
  nameWithType: "TokenStream.e"
  fullName: "io.token.TokenStream.e"
  package: "io.token"
- uid: "io.token.TokenStream.ne*"
  name: "ne"
  nameWithType: "TokenStream.ne"
  fullName: "io.token.TokenStream.ne"
  package: "io.token"
- uid: "java.lang.Object.notify()"
  name: "Object.notify()"
  nameWithType: "Object.notify()"
  fullName: "java.lang.Object.notify()"
- uid: "java.lang.Object.wait()"
  name: "Object.wait()"
  nameWithType: "Object.wait()"
  fullName: "java.lang.Object.wait()"
- uid: "java.lang.Object.finalize()"
  name: "Object.finalize()"
  nameWithType: "Object.finalize()"
  fullName: "java.lang.Object.finalize()"
- uid: "java.lang.Object.clone()"
  name: "Object.clone()"
  nameWithType: "Object.clone()"
  fullName: "java.lang.Object.clone()"
- uid: "java.lang.Object.notifyAll()"
  name: "Object.notifyAll()"
  nameWithType: "Object.notifyAll()"
  fullName: "java.lang.Object.notifyAll()"
- uid: "java.lang.Object.equals(java.lang.Object)"
  name: "Object.equals(Object)"
  nameWithType: "Object.equals(Object)"
  fullName: "java.lang.Object.equals(java.lang.Object)"
- uid: "java.lang.Object.getClass()"
  name: "Object.getClass()"
  nameWithType: "Object.getClass()"
  fullName: "java.lang.Object.getClass()"
- uid: "java.lang.Object.wait(long)"
  name: "Object.wait(long)"
  nameWithType: "Object.wait(long)"
  fullName: "java.lang.Object.wait(long)"
- uid: "java.lang.Object.hashCode()"
  name: "Object.hashCode()"
  nameWithType: "Object.hashCode()"
  fullName: "java.lang.Object.hashCode()"
- uid: "java.lang.Object.wait(long,int)"
  name: "Object.wait(long,int)"
  nameWithType: "Object.wait(long,int)"
  fullName: "java.lang.Object.wait(long,int)"
- uid: "java.lang.Object.toString()"
  name: "Object.toString()"
  nameWithType: "Object.toString()"
  fullName: "java.lang.Object.toString()"
- uid: "io.token.Token"
  name: "Token"
  nameWithType: "Token"
  fullName: "io.token.Token"
- uid: "java.util.function.Predicate"
  name: "Predicate"
  nameWithType: "Predicate"
  fullName: "java.util.function.Predicate"
- uid: "java.util.LinkedList"
  name: "LinkedList"
  nameWithType: "LinkedList"
  fullName: "java.util.LinkedList"

### YamlMime:ManagedReference
items:
- uid: "ai.statemachine.StateMachine"
  id: "StateMachine"
  parent: "ai.statemachine"
  children:
  - "ai.statemachine.StateMachine.StateMachine()"
  - "ai.statemachine.StateMachine.addState(java.lang.String,ai.statemachine.State)"
  - "ai.statemachine.StateMachine.addTransition(java.lang.String,java.lang.String,java.util.function.Function<ai.statemachine.State,java.lang.Boolean>)"
  - "ai.statemachine.StateMachine.canTransitionTo(java.lang.String)"
  - "ai.statemachine.StateMachine.doTransition(java.lang.String)"
  - "ai.statemachine.StateMachine.getCurrentState()"
  - "ai.statemachine.StateMachine.getCurrentStateName()"
  - "ai.statemachine.StateMachine.hasState(java.lang.String)"
  - "ai.statemachine.StateMachine.hasTransition(java.lang.String)"
  - "ai.statemachine.StateMachine.hasTransition(java.lang.String,java.lang.String)"
  - "ai.statemachine.StateMachine.startMachine(java.lang.String)"
  - "ai.statemachine.StateMachine.update(float)"
  - "ai.statemachine.StateMachine.validate()"
  langs:
  - "java"
  name: "StateMachine"
  nameWithType: "StateMachine"
  fullName: "ai.statemachine.StateMachine"
  type: "Class"
  package: "ai.statemachine"
  summary: "A flexible implementation of a statemachine. This class can represent a deterministic or non-deterministic statemachine, however the actual transitions will never be random, therefore all statemachines are predictable in their transitions. It involves an unlimited number of states and transitions between them, which can be automated by adding conditions to them."
  syntax:
    content: "public class StateMachine"
  inheritance:
  - "java.lang.Object"
  inheritedMembers:
  - "java.lang.Object.clone()"
  - "java.lang.Object.equals(java.lang.Object)"
  - "java.lang.Object.finalize()"
  - "java.lang.Object.getClass()"
  - "java.lang.Object.hashCode()"
  - "java.lang.Object.notify()"
  - "java.lang.Object.notifyAll()"
  - "java.lang.Object.toString()"
  - "java.lang.Object.wait()"
  - "java.lang.Object.wait(long)"
  - "java.lang.Object.wait(long,int)"
- uid: "ai.statemachine.StateMachine.StateMachine()"
  id: "StateMachine()"
  parent: "ai.statemachine.StateMachine"
  langs:
  - "java"
  name: "StateMachine()"
  nameWithType: "StateMachine.StateMachine()"
  fullName: "ai.statemachine.StateMachine.StateMachine()"
  overload: "ai.statemachine.StateMachine.StateMachine*"
  type: "Constructor"
  package: "ai.statemachine"
  summary: "Create a statemachine with no states or transitions."
  syntax:
    content: "public StateMachine()"
- uid: "ai.statemachine.StateMachine.addState(java.lang.String,ai.statemachine.State)"
  id: "addState(java.lang.String,ai.statemachine.State)"
  parent: "ai.statemachine.StateMachine"
  langs:
  - "java"
  name: "addState(String name, State state)"
  nameWithType: "StateMachine.addState(String name, State state)"
  fullName: "ai.statemachine.StateMachine.addState(String name, State state)"
  overload: "ai.statemachine.StateMachine.addState*"
  type: "Method"
  package: "ai.statemachine"
  summary: "Adds a new state to the machine."
  syntax:
    content: "public boolean addState(String name, State state)"
    parameters:
    - id: "name"
      type: "java.lang.String"
      description: "the name of the new state"
    - id: "state"
      type: "ai.statemachine.State"
      description: "the new state"
    return:
      type: "boolean"
      description: "false if the state could not be added or a state with identical name already existed"
- uid: "ai.statemachine.StateMachine.addTransition(java.lang.String,java.lang.String,java.util.function.Function<ai.statemachine.State,java.lang.Boolean>)"
  id: "addTransition(java.lang.String,java.lang.String,java.util.function.Function<ai.statemachine.State,java.lang.Boolean>)"
  parent: "ai.statemachine.StateMachine"
  langs:
  - "java"
  name: "addTransition(String fromState, String toState, Function<State,Boolean> condition)"
  nameWithType: "StateMachine.addTransition(String fromState, String toState, Function<State,Boolean> condition)"
  fullName: "ai.statemachine.StateMachine.addTransition(String fromState, String toState, Function<State,Boolean> condition)"
  overload: "ai.statemachine.StateMachine.addTransition*"
  type: "Method"
  package: "ai.statemachine"
  summary: "Add a new transition."
  syntax:
    content: "public boolean addTransition(String fromState, String toState, Function<State,Boolean> condition)"
    parameters:
    - id: "fromState"
      type: "java.lang.String"
    - id: "toState"
      type: "java.lang.String"
    - id: "condition"
      type: "java.util.function.Function<ai.statemachine.State,java.lang.Boolean>"
    return:
      type: "boolean"
      description: "false, if the states are unknown"
- uid: "ai.statemachine.StateMachine.canTransitionTo(java.lang.String)"
  id: "canTransitionTo(java.lang.String)"
  parent: "ai.statemachine.StateMachine"
  langs:
  - "java"
  name: "canTransitionTo(String state)"
  nameWithType: "StateMachine.canTransitionTo(String state)"
  fullName: "ai.statemachine.StateMachine.canTransitionTo(String state)"
  overload: "ai.statemachine.StateMachine.canTransitionTo*"
  type: "Method"
  package: "ai.statemachine"
  summary: "Check if there is any known state that can transition to the given state."
  syntax:
    content: "public boolean canTransitionTo(String state)"
    parameters:
    - id: "state"
      type: "java.lang.String"
      description: "the name of the state to potentially transition to"
    return:
      type: "boolean"
      description: "true if and only if there is any state that has a transition to the given one"
- uid: "ai.statemachine.StateMachine.doTransition(java.lang.String)"
  id: "doTransition(java.lang.String)"
  parent: "ai.statemachine.StateMachine"
  langs:
  - "java"
  name: "doTransition(String toState)"
  nameWithType: "StateMachine.doTransition(String toState)"
  fullName: "ai.statemachine.StateMachine.doTransition(String toState)"
  overload: "ai.statemachine.StateMachine.doTransition*"
  type: "Method"
  package: "ai.statemachine"
  summary: "Attempts to transition to the given state."
  syntax:
    content: "public boolean doTransition(String toState)"
    parameters:
    - id: "toState"
      type: "java.lang.String"
      description: "the state to transition to"
    return:
      type: "boolean"
      description: "false, if and only if the given stte is unknown or null"
- uid: "ai.statemachine.StateMachine.getCurrentState()"
  id: "getCurrentState()"
  parent: "ai.statemachine.StateMachine"
  langs:
  - "java"
  name: "getCurrentState()"
  nameWithType: "StateMachine.getCurrentState()"
  fullName: "ai.statemachine.StateMachine.getCurrentState()"
  overload: "ai.statemachine.StateMachine.getCurrentState*"
  type: "Method"
  package: "ai.statemachine"
  syntax:
    content: "public State getCurrentState()"
    return:
      type: "ai.statemachine.State"
      description: "the current <xref uid=\"ai.statemachine.State\" data-throw-if-not-resolved=\"false\">State</xref> of the machine"
- uid: "ai.statemachine.StateMachine.getCurrentStateName()"
  id: "getCurrentStateName()"
  parent: "ai.statemachine.StateMachine"
  langs:
  - "java"
  name: "getCurrentStateName()"
  nameWithType: "StateMachine.getCurrentStateName()"
  fullName: "ai.statemachine.StateMachine.getCurrentStateName()"
  overload: "ai.statemachine.StateMachine.getCurrentStateName*"
  type: "Method"
  package: "ai.statemachine"
  syntax:
    content: "public String getCurrentStateName()"
    return:
      type: "java.lang.String"
- uid: "ai.statemachine.StateMachine.hasState(java.lang.String)"
  id: "hasState(java.lang.String)"
  parent: "ai.statemachine.StateMachine"
  langs:
  - "java"
  name: "hasState(String name)"
  nameWithType: "StateMachine.hasState(String name)"
  fullName: "ai.statemachine.StateMachine.hasState(String name)"
  overload: "ai.statemachine.StateMachine.hasState*"
  type: "Method"
  package: "ai.statemachine"
  summary: "Check if a state is known by its name."
  syntax:
    content: "public boolean hasState(String name)"
    parameters:
    - id: "name"
      type: "java.lang.String"
      description: "the name of the state"
    return:
      type: "boolean"
      description: "true if and only if there is a state by this name"
- uid: "ai.statemachine.StateMachine.hasTransition(java.lang.String)"
  id: "hasTransition(java.lang.String)"
  parent: "ai.statemachine.StateMachine"
  langs:
  - "java"
  name: "hasTransition(String state)"
  nameWithType: "StateMachine.hasTransition(String state)"
  fullName: "ai.statemachine.StateMachine.hasTransition(String state)"
  overload: "ai.statemachine.StateMachine.hasTransition*"
  type: "Method"
  package: "ai.statemachine"
  summary: "Check if there is any known transition outgoing from the given state."
  syntax:
    content: "public boolean hasTransition(String state)"
    parameters:
    - id: "state"
      type: "java.lang.String"
      description: "the name of the state to transition from"
    return:
      type: "boolean"
      description: "true if and only if there is any transition starting at the given state"
- uid: "ai.statemachine.StateMachine.hasTransition(java.lang.String,java.lang.String)"
  id: "hasTransition(java.lang.String,java.lang.String)"
  parent: "ai.statemachine.StateMachine"
  langs:
  - "java"
  name: "hasTransition(String fromState, String toState)"
  nameWithType: "StateMachine.hasTransition(String fromState, String toState)"
  fullName: "ai.statemachine.StateMachine.hasTransition(String fromState, String toState)"
  overload: "ai.statemachine.StateMachine.hasTransition*"
  type: "Method"
  package: "ai.statemachine"
  summary: "Check if there is transition from a given state to a given state by their names."
  syntax:
    content: "public boolean hasTransition(String fromState, String toState)"
    parameters:
    - id: "fromState"
      type: "java.lang.String"
      description: "the name of the state to start"
    - id: "toState"
      type: "java.lang.String"
      description: "the name of the state to potentially transition to"
    return:
      type: "boolean"
      description: "true if and only if there is at least one know transition"
- uid: "ai.statemachine.StateMachine.startMachine(java.lang.String)"
  id: "startMachine(java.lang.String)"
  parent: "ai.statemachine.StateMachine"
  langs:
  - "java"
  name: "startMachine(String startState)"
  nameWithType: "StateMachine.startMachine(String startState)"
  fullName: "ai.statemachine.StateMachine.startMachine(String startState)"
  overload: "ai.statemachine.StateMachine.startMachine*"
  type: "Method"
  package: "ai.statemachine"
  summary: "Attempts to start the state machine. This is required to set the starting/current state of the machine and enable the update loop. The method <xref uid=\"ai.statemachine.StateMachine.doTransition(java.lang.String)\" data-throw-if-not-resolved=\"false\">#doTransition(String)</xref> will fail as well, before this method is called."
  syntax:
    content: "public boolean startMachine(String startState)"
    parameters:
    - id: "startState"
      type: "java.lang.String"
      description: "the state to start from"
    return:
      type: "boolean"
      description: "false, if the the statemachine could not be started, because\n - startState is null\n - startState is not known to the machine\n - currentState is already not null, so machine already started"
- uid: "ai.statemachine.StateMachine.update(float)"
  id: "update(float)"
  parent: "ai.statemachine.StateMachine"
  langs:
  - "java"
  name: "update(float dt)"
  nameWithType: "StateMachine.update(float dt)"
  fullName: "ai.statemachine.StateMachine.update(float dt)"
  overload: "ai.statemachine.StateMachine.update*"
  type: "Method"
  package: "ai.statemachine"
  summary: "Update loop method. Will do nothing, if the machine is not started."
  syntax:
    content: "public void update(float dt)"
    parameters:
    - id: "dt"
      type: "float"
      description: "the delta time"
- uid: "ai.statemachine.StateMachine.validate()"
  id: "validate()"
  parent: "ai.statemachine.StateMachine"
  langs:
  - "java"
  name: "validate()"
  nameWithType: "StateMachine.validate()"
  fullName: "ai.statemachine.StateMachine.validate()"
  overload: "ai.statemachine.StateMachine.validate*"
  type: "Method"
  package: "ai.statemachine"
  summary: "Validate whether the state machine does not contain unreachable or deadlock states."
  syntax:
    content: "public boolean validate()"
    return:
      type: "boolean"
      description: "false if and only if there are states, that do not transition or are orphaned"
references:
- uid: "ai.statemachine.StateMachine.StateMachine*"
  name: "StateMachine"
  nameWithType: "StateMachine.StateMachine"
  fullName: "ai.statemachine.StateMachine.StateMachine"
  package: "ai.statemachine"
- uid: "java.lang.String"
  spec.java:
  - uid: "java.lang.String"
    name: "String"
    fullName: "java.lang.String"
- uid: "ai.statemachine.StateMachine.getCurrentStateName*"
  name: "getCurrentStateName"
  nameWithType: "StateMachine.getCurrentStateName"
  fullName: "ai.statemachine.StateMachine.getCurrentStateName"
  package: "ai.statemachine"
- uid: "ai.statemachine.State"
  name: "State"
  nameWithType: "State"
  fullName: "ai.statemachine.State"
- uid: "ai.statemachine.StateMachine.getCurrentState*"
  name: "getCurrentState"
  nameWithType: "StateMachine.getCurrentState"
  fullName: "ai.statemachine.StateMachine.getCurrentState"
  package: "ai.statemachine"
- uid: "boolean"
  spec.java:
  - uid: "boolean"
    name: "boolean"
    fullName: "boolean"
- uid: "ai.statemachine.StateMachine.hasTransition*"
  name: "hasTransition"
  nameWithType: "StateMachine.hasTransition"
  fullName: "ai.statemachine.StateMachine.hasTransition"
  package: "ai.statemachine"
- uid: "ai.statemachine.StateMachine.canTransitionTo*"
  name: "canTransitionTo"
  nameWithType: "StateMachine.canTransitionTo"
  fullName: "ai.statemachine.StateMachine.canTransitionTo"
  package: "ai.statemachine"
- uid: "ai.statemachine.StateMachine.hasState*"
  name: "hasState"
  nameWithType: "StateMachine.hasState"
  fullName: "ai.statemachine.StateMachine.hasState"
  package: "ai.statemachine"
- uid: "ai.statemachine.StateMachine.addState*"
  name: "addState"
  nameWithType: "StateMachine.addState"
  fullName: "ai.statemachine.StateMachine.addState"
  package: "ai.statemachine"
- uid: "java.util.function.Function<ai.statemachine.State,java.lang.Boolean>"
  spec.java:
  - uid: "java.util.function.Function"
    name: "Function"
    fullName: "java.util.function.Function"
  - name: "<"
    fullName: "<"
  - uid: "ai.statemachine.State"
    name: "State"
    fullName: "ai.statemachine.State"
  - name: ","
    fullName: ","
  - uid: "java.lang.Boolean"
    name: "Boolean"
    fullName: "java.lang.Boolean"
  - name: ">"
    fullName: ">"
- uid: "ai.statemachine.StateMachine.addTransition*"
  name: "addTransition"
  nameWithType: "StateMachine.addTransition"
  fullName: "ai.statemachine.StateMachine.addTransition"
  package: "ai.statemachine"
- uid: "ai.statemachine.StateMachine.startMachine*"
  name: "startMachine"
  nameWithType: "StateMachine.startMachine"
  fullName: "ai.statemachine.StateMachine.startMachine"
  package: "ai.statemachine"
- uid: "ai.statemachine.StateMachine.doTransition*"
  name: "doTransition"
  nameWithType: "StateMachine.doTransition"
  fullName: "ai.statemachine.StateMachine.doTransition"
  package: "ai.statemachine"
- uid: "ai.statemachine.StateMachine.validate*"
  name: "validate"
  nameWithType: "StateMachine.validate"
  fullName: "ai.statemachine.StateMachine.validate"
  package: "ai.statemachine"
- uid: "float"
  spec.java:
  - uid: "float"
    name: "float"
    fullName: "float"
- uid: "ai.statemachine.StateMachine.update*"
  name: "update"
  nameWithType: "StateMachine.update"
  fullName: "ai.statemachine.StateMachine.update"
  package: "ai.statemachine"
- uid: "java.lang.Object.notify()"
  name: "Object.notify()"
  nameWithType: "Object.notify()"
  fullName: "java.lang.Object.notify()"
- uid: "java.lang.Object.wait()"
  name: "Object.wait()"
  nameWithType: "Object.wait()"
  fullName: "java.lang.Object.wait()"
- uid: "java.lang.Object.finalize()"
  name: "Object.finalize()"
  nameWithType: "Object.finalize()"
  fullName: "java.lang.Object.finalize()"
- uid: "java.lang.Object.clone()"
  name: "Object.clone()"
  nameWithType: "Object.clone()"
  fullName: "java.lang.Object.clone()"
- uid: "java.lang.Object.notifyAll()"
  name: "Object.notifyAll()"
  nameWithType: "Object.notifyAll()"
  fullName: "java.lang.Object.notifyAll()"
- uid: "java.lang.Object.equals(java.lang.Object)"
  name: "Object.equals(Object)"
  nameWithType: "Object.equals(Object)"
  fullName: "java.lang.Object.equals(java.lang.Object)"
- uid: "java.lang.Object.getClass()"
  name: "Object.getClass()"
  nameWithType: "Object.getClass()"
  fullName: "java.lang.Object.getClass()"
- uid: "java.lang.Object.wait(long)"
  name: "Object.wait(long)"
  nameWithType: "Object.wait(long)"
  fullName: "java.lang.Object.wait(long)"
- uid: "java.lang.Object.hashCode()"
  name: "Object.hashCode()"
  nameWithType: "Object.hashCode()"
  fullName: "java.lang.Object.hashCode()"
- uid: "java.lang.Object.wait(long,int)"
  name: "Object.wait(long,int)"
  nameWithType: "Object.wait(long,int)"
  fullName: "java.lang.Object.wait(long,int)"
- uid: "java.lang.Object.toString()"
  name: "Object.toString()"
  nameWithType: "Object.toString()"
  fullName: "java.lang.Object.toString()"
- uid: "ai.statemachine.State,java.lang.Boolean"
  name: "State,Boolean"
  nameWithType: "State,Boolean"
  fullName: "ai.statemachine.State,java.lang.Boolean"
- uid: "java.util.function.Function"
  name: "Function"
  nameWithType: "Function"
  fullName: "java.util.function.Function"
